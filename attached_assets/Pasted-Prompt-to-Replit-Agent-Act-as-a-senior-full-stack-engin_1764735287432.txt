Prompt to Replit Agent:

Act as a senior full-stack engineer.
Your task is to professionalize and harden the API configuration layer for this B2B wholesale portal, without breaking any existing UI or flows.

1. General goals

Keep all current features working (customer dashboard, admin dashboard, staff login, mockApi, localStorage logic, etc.).

Do not change any UI/UX, styling, layout, or text labels.

Focus only on the API/config/client layer and internal logic.

2. Central API config

Create a dedicated configuration module, for example:
src/services/apiConfig.ts
It should export a strongly typed config object that includes at least:

env (e.g., "development" | "production" | "test")

apiMode (e.g., "mock" | "rest") â€“ default should be "mock"

baseUrl for the real backend API (read from environment variables)

timeouts (ms), default headers, and a configurable retries count.

Read secrets and base URLs from environment variables or Replit secrets, e.g.:

VITE_API_BASE_URL (or similar)

VITE_API_KEY if needed later
but make sure the app still runs even if these env vars are missing (it should fall back to mock mode).

Add clear TypeScript types/interfaces for the config so that using it is type-safe across the app.

3. API client (HTTP layer)

Create a single, reusable HTTP client module, for example:
src/services/httpClient.ts

This client should:

Use fetch or axios (if axios is already in the project, reuse it; otherwise you may add it).

Inject the base URL from apiConfig.

Attach default headers (JSON, auth token placeholder, etc.).

Implement a small retry mechanism based on apiConfig.retries.

Normalize responses and errors into a consistent shape, e.g. { data, error, status }.

Add centralized error handling:

Log errors in console.error with enough context (URL, method, status, payload).

Return friendly error messages to the calling services instead of throwing raw errors.

4. Service layer and mockApi integration

Keep mockApi as the default implementation for now, but refactor the code so that:

There is a clean service interface for core entities (customers, quotes, imports, staff, etc.).

Each service has two possible implementations: mock (current localStorage + mockApi) and rest (future real backend).

Implement a switching mechanism based on apiConfig.apiMode:

When apiMode === "mock", use the existing mockApi functions.

When apiMode === "rest", route calls through the new httpClient and real endpoints (you can stub or design the REST endpoints with TODO comments if the backend is not ready yet).

Make sure all existing hooks/components that call mockApi are updated to go through the new service layer (or at least provide a wrapper that keeps the old names but internally delegates to the service).

5. Types & DTOs

Define shared TypeScript types/DTOs for:

customer, staff, admin, quote, missingPart, importRequest, notification, etc.

Ensure both mock and future REST implementations use the same types.

Add strict typing to all service methods and API responses to catch mistakes at compile time.

6. Developer experience & documentation

Add JSDoc / TSDoc comments to:

apiConfig

httpClient

each main service (e.g., quoteService, importService, authService).

Add a short README_API.md in the root or docs folder that explains:

How to switch between mock and rest modes.

Which env vars to set for production.

Where to add new endpoints/services in the future.

Ensure the app still starts with npm run dev / npm run build without any additional manual steps.

7. Non-breaking constraint

After you finish, run the app, log in as owner/staff/customer, and verify that:

All dashboards still load correctly.

All existing mock flows (quotes, imports, missing parts, CRM interactions) still work using localStorage/mockApi.

If anything breaks, fix it before finalizing.