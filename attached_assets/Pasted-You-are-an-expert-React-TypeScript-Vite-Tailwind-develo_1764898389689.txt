You are an expert React + TypeScript + Vite + Tailwind developer working inside an existing “SINI CAR – B2B Wholesale Customer Portal” project.

IMPORTANT RULES (DO NOT BREAK):
- Do NOT delete or rename any existing files.
- Do NOT rewrite the project from scratch.
- Do NOT change existing business logic outside pricing.
- Do NOT change or remove any existing Arabic or English texts, except when adding NEW UI labels for the pricing center.
- Do NOT switch from mock/localStorage to a real backend. Keep using the existing mockApi/localStorage pattern.
- All new pricing behavior must be fully configurable from the admin UI (no hard-coded pricing rules in the code).

VERY IMPORTANT:
In addition to my specifications below, you should also:
- Propose and implement your own reasonable ideas and improvements for the Pricing Center, as long as:
  - They are fully configurable from the admin UI,
  - They do NOT break existing features,
  - They do NOT require a real backend,
  - They stay consistent with the current design and architecture.
If you think of a useful feature for pricing management (e.g. bulk operations, tags, groups, presets, audit notes, etc.), feel free to add it as long as it follows the rules above.

Your main task:  
ADD a complete, highly configurable “Pricing Center” (إدارة مركز التسعيرات) in the admin panel, plus a centralized pricing engine that is driven entirely by settings stored in mockApi/localStorage.

The main goal:  
**The admin must be able to change EVERYTHING about pricing (levels, formulas, per-customer overrides, precedence, rounding, default levels…) from the UI, WITHOUT touching the code.**

Work STEP BY STEP and update all related files carefully.

============================================================
STEP 0 – UNDERSTAND PROJECT STRUCTURE (READ ONLY)
============================================================

1. Locate:
   - The central types file (e.g. types.ts).
   - mockApi service (e.g. services/mockApi.ts).
   - Customer model / Business profile model.
   - Admin layout & admin routes (where other admin pages like orders, products, settings live).
   - Customer-facing product listing / quotation / pricing components (where product prices are currently shown).
2. Do NOT modify anything yet. Just identify where to plug in.

============================================================
STEP 1 – DEFINE CORE PRICING TYPES (CONFIG-DRIVEN)
============================================================

Open the central types file (e.g. types.ts) and ADD the following new types (or similar):

1) PriceLevel – defines each pricing level, fully configurable:

export interface PriceLevel {
  id: string;             // internal ID, e.g. "L1", "VIP", etc.
  code: string;           // short code visible to admin (e.g. "1", "2", "VIP")
  name: string;           // Arabic display name, e.g. "مستوى 1", "مستوى كبار العملاء"
  description?: string;
  isBaseLevel: boolean;   // true if this level is a base level (not derived from another level)
  baseLevelId?: string;   // for derived levels: which level it is calculated from
  adjustmentType?: 'PERCENT' | 'FIXED'; // how it is derived from base
  adjustmentValue?: number; // e.g. +10% or +20 SAR from base
  isActive: boolean;
  sortOrder: number;
}

2) ProductPriceEntry – price per product per level (explicit matrix entries):

export interface ProductPriceEntry {
  id: string;
  productId: string;
  priceLevelId: string;
  price: number;          // explicit price for this product & level
  currency?: string;      // optional, default from global settings
}

3) CustomerPricingProfile – per-customer pricing configuration:

export interface CustomerPricingProfile {
  customerId: string;
  defaultPriceLevelId: string;    // which level is the base for this customer
  extraMarkupPercent?: number;    // +% on top of level price
  extraDiscountPercent?: number;  // -% on top of level price
  allowCustomRules: boolean;      // whether special rules apply
  customRules?: CustomerCustomPriceRule[];
}

4) CustomerCustomPriceRule – overrides for products or categories:

export interface CustomerCustomPriceRule {
  id: string;
  productId?: string;     // specific product override (optional)
  categoryId?: string;    // optional category override if categories exist
  useFixedPrice?: boolean;
  fixedPrice?: number;    // override with this fixed price
  usePercentOfLevel?: boolean;
  percentOfLevel?: number; // e.g. 80 = 80% of base level price
  priceLevelIdForPercent?: string; // which level to use as base for % calculation
}

5) GlobalPricingSettings – master configuration for all pricing logic:

export interface GlobalPricingSettings {
  defaultPriceLevelId: string | null;  // used when customer has no profile
  currency: string;                    // e.g. "SAR"
  roundingMode: 'NONE' | 'ROUND' | 'CEIL' | 'FLOOR';
  roundingDecimals: number;            // number of decimals after rounding
  pricePrecedenceOrder: Array<'CUSTOM_RULE' | 'LEVEL_EXPLICIT' | 'LEVEL_DERIVED'>;
  allowNegativeDiscounts: boolean;     // whether discount can exceed markup
  allowFallbackToOtherLevels: boolean; // if missing a price for given level
  fallbackLevelId?: string | null;     // optional fallback level
}

Make sure all new types are exported and do NOT break existing types.

Also, extend the existing customer / business profile type to optionally include a reference to CustomerPricingProfile, e.g.:

pricingProfile?: CustomerPricingProfile;

Keep it optional to avoid breaking old data.

If you think of additional useful metadata that keeps pricing flexible (e.g. tags, segments, min/max price constraints), you may add them as optional fields, but keep them generic and configurable.

============================================================
STEP 2 – EXTEND mockApi FOR PRICING STORAGE (FULLY CONFIGURABLE)
============================================================

Open services/mockApi.ts and:

1) Add new STORAGE KEYS (constants) for pricing:

- PRICE_LEVELS
- PRODUCT_PRICE_MATRIX
- GLOBAL_PRICING_SETTINGS
- CUSTOMER_PRICING_PROFILES

Example:

PRICE_LEVELS: 'sini_price_levels',
PRODUCT_PRICE_MATRIX: 'sini_price_matrix',
GLOBAL_PRICING_SETTINGS: 'sini_global_pricing_settings',
CUSTOMER_PRICING_PROFILES: 'sini_customer_pricing_profiles',

2) Implement CRUD-like functions:

- getPriceLevels(): Promise<PriceLevel[]>
- savePriceLevels(levels: PriceLevel[]): Promise<void>

- getProductPriceMatrix(): Promise<ProductPriceEntry[]>
- saveProductPriceMatrix(entries: ProductPriceEntry[]): Promise<void>

- getGlobalPricingSettings(): Promise<GlobalPricingSettings>
- saveGlobalPricingSettings(settings: GlobalPricingSettings): Promise<void>

- getCustomerPricingProfile(customerId: string): Promise<CustomerPricingProfile | null>
- upsertCustomerPricingProfile(profile: CustomerPricingProfile): Promise<void>

All of these must read/write to LocalStorage using the same pattern used elsewhere in mockApi.  
If there is a helper like safeParse, use it to avoid crashes.

3) Initialize sensible DEFAULT values when nothing is stored yet:

- For getPriceLevels:
  - If no levels exist, create one default base level, e.g.:
    id: 'L1', code: '1', name: 'المستوى 1 الافتراضي', isBaseLevel: true, isActive: true, sortOrder: 1

- For getGlobalPricingSettings:
  - If not found, return defaults such as:
    - defaultPriceLevelId: the default level you initialized
    - currency: 'SAR'
    - roundingMode: 'ROUND'
    - roundingDecimals: 2
    - pricePrecedenceOrder: ['CUSTOM_RULE', 'LEVEL_EXPLICIT', 'LEVEL_DERIVED']
    - allowNegativeDiscounts: false
    - allowFallbackToOtherLevels: true

Do NOT hard-code any business price numbers in the code (like 100, 200, 300).  
All numeric values for prices or percent-based adjustments must come from these settings and matrix entries.

If you have additional ideas for pricing data (e.g. “price zones”, “time-based promotions”, or “volume-based adjustments”), you may add optional storage keys and methods, as long as they remain configuration-driven and controlled from the UI.

============================================================
STEP 3 – CREATE CENTRAL PRICING ENGINE (services/pricingEngine.ts)
============================================================

Create a new file: services/pricingEngine.ts

This file will export ONE main function:

- getEffectivePriceForCustomer(productId: string, customerId: string | null): Promise<number | null>

Internally it should:

1) Load:
   - GlobalPricingSettings
   - PriceLevels[]
   - ProductPriceEntry[]
   - CustomerPricingProfile (if customerId is provided)

2) Determine which price-level and rules apply:
   - If a CustomerPricingProfile exists:
     - Use profile.defaultPriceLevelId
     - Apply profile.extraMarkupPercent / extraDiscountPercent
     - If allowCustomRules && customRules present:
       - Look for rule matching productId (or category, if supported).
   - If no profile:
     - Use GlobalPricingSettings.defaultPriceLevelId

3) Apply price precedence, using GlobalPricingSettings.pricePrecedenceOrder in this exact order:

For each precedence entry:

- 'CUSTOM_RULE':
  - If a CustomerCustomPriceRule exists for this product:
    - If useFixedPrice && fixedPrice is defined → use this as base price.
    - Else if usePercentOfLevel and percentOfLevel + priceLevelIdForPercent defined:
      - Get base level explicit/derived price for that level.
      - Multiply by percentOfLevel / 100.

- 'LEVEL_EXPLICIT':
  - Look for ProductPriceEntry where productId & priceLevelId match the chosen customer default level.
  - If found, use that price as base.

- 'LEVEL_DERIVED':
  - If no explicit price:
    - Use the chosen PriceLevel definition:
      - If isBaseLevel:
        - No explicit price = we cannot derive; optionally fallback to another level if allowFallbackToOtherLevels is true.
      - If not base: locate its baseLevelId and adjustmentType/adjustmentValue and calculate derived price from base level price.

4) After base price is found:
   - Apply any extraMarkupPercent and extraDiscountPercent from the CustomerPricingProfile.
     final = base * (1 + markup/100 - discount/100)
   - Apply GlobalPricingSettings.roundingMode and roundingDecimals.

5) If no valid price could be found in any of the precedence steps:
   - Return null to indicate "not priced".

This engine must NOT hard-code any numeric rules.  
Everything must come from configuration (PriceLevels, ProductPriceMatrix, CustomerProfiles, GlobalSettings).

If you have ideas to extend the engine (for example, volume discounts, minimum margin checks, price floors/ceilings), you may add them but they MUST be controlled via new optional fields in GlobalPricingSettings or related types, and configurable from the admin UI.

============================================================
STEP 4 – ADMIN “PRICING CENTER” PAGE (FULLY CONFIGURABLE UI)
============================================================

Create a new admin page component, for example:

- components/AdminPricingCenter.tsx
(or follow existing convention, e.g. pages/admin/AdminPricingCenter.tsx)

This page should use tabs or sections with 4 main areas:

1) Price Levels Management (إدارة مستويات التسعير)
2) Product Price Matrix (مصفوفة أسعار المنتجات)
3) Customer Pricing Profiles (تسعير العملاء)
4) Global Pricing Settings & Simulation (الإعدادات العامة + المحاكاة)

Make the UI simple but powerful and DRIVEN BY SETTINGS:

1) Price Levels tab:
   - Table of existing PriceLevels:
     - columns: code, name, description, isBaseLevel, baseLevelId, adjustmentType, adjustmentValue, isActive, sortOrder
   - "Add new level" form:
     - code, name, description, isBaseLevel (checkbox)
     - if isBaseLevel = false → choose baseLevelId + adjustmentType + adjustmentValue
   - Allow editing and toggling isActive.
   - Save all levels via mockApi.savePriceLevels.
   - You may add helpful UI extras such as:
     - drag-and-drop to reorder levels by sortOrder,
     - quick actions like “duplicate level”.

2) Product Price Matrix tab:
   - Simple table:
     - productId or productCode input
     - priceLevelId (select)
     - price (number)
   - Buttons:
     - "Add entry" (add row)
     - "Import from Excel" (if xlsx tooling already exists in the project, you can reuse it)
     - "Export to Excel" (optional)
   - Save via mockApi.saveProductPriceMatrix.
   - This matrix is the ONLY place where raw prices are entered manually.
   - You may add filters/search by productCode or level for better UX.

3) Customer Pricing Profiles tab:
   - List all customers (or provide search) and show:
     - defaultPriceLevelId
     - extraMarkupPercent
     - extraDiscountPercent
   - When selecting a customer:
     - Show a form:
       - defaultPriceLevelId (select from PriceLevels)
       - extraMarkupPercent
       - extraDiscountPercent
       - allowCustomRules (checkbox)
       - customRules table:
         - productId
         - useFixedPrice, fixedPrice
         - usePercentOfLevel, percentOfLevel, priceLevelIdForPercent
     - Save via upsertCustomerPricingProfile.
   - You may add useful extras such as:
     - “Copy pricing from another customer”
     - “Reset to global defaults”.

4) Global Pricing Settings & Simulation tab:
   - Form for GlobalPricingSettings:
     - defaultPriceLevelId (select from levels)
     - currency
     - roundingMode (NONE/ROUND/CEIL/FLOOR)
     - roundingDecimals
     - pricePrecedenceOrder (multi-select or drag/drop for CUSTOM_RULE / LEVEL_EXPLICIT / LEVEL_DERIVED)
     - allowNegativeDiscounts (boolean)
     - allowFallbackToOtherLevels (boolean)
     - fallbackLevelId (optional level)
   - Save via saveGlobalPricingSettings.
   - Below the settings, add a simple simulation form:
     - customerId (select)
     - productId (input/select)
     - Button: "احسب السعر"
     - Call getEffectivePriceForCustomer and display result in a card, showing also:
       - which precedence rule was used (custom / explicit / derived)
       - which level was selected
   - This gives the admin a way to verify pricing behavior without changing code.

Throughout this page, keep the UI consistent with existing admin design (same fonts, colors, spacing, and layout conventions).

============================================================
STEP 5 – WIRE ADMIN PRICING CENTER INTO ROUTES & SIDEBAR
============================================================

1) Find admin routes (e.g. in App.tsx or a dedicated routes file).
2) Add a new route:
   - path: /admin/pricing
   - component: AdminPricingCenter
3) Find admin sidebar / navigation.
4) Add a new item:
   - Label: "مركز التسعيرات"
   - Icon: reuse existing icon style (e.g. a Money/Tag icon from lucide-react if used elsewhere).
   - Link: /admin/pricing
   - Respect existing permission system (only admin/owner roles can see/manage this page).

Do NOT remove or change existing menu items.

============================================================
STEP 6 – INTEGRATE PRICING ENGINE INTO CUSTOMER & QUOTE UI
============================================================

Goal: all customer-facing prices should go through the new pricing engine so that admin can fully control behavior from the “Pricing Center” without code changes.

1) Identify where product prices are currently shown:
   - e.g. product listing, quote request page, cart/summary pages.

2) Wherever a unit price is needed:
   - Replace the old direct price usage (e.g. product.price) with a call to:
     - getEffectivePriceForCustomer(productId, currentCustomerId)
   - If currentCustomerId is not known (not logged in), use null and fall back to GlobalPricingSettings.defaultPriceLevelId.

3) Handle the case where getEffectivePriceForCustomer returns null:
   - Show "غير مسعّر" or a similar UI indicating the product needs manual pricing.
   - Do NOT crash the component.

4) Do NOT hard-code any numeric price in the UI. Always use the result of the pricing engine.

If you see a place where an additional indicator would help the user (e.g. tooltips explaining the price source: “سعر مستوى 1 + 10% عمولة العميل”), you may add small explanatory text, but do NOT remove existing labels.

============================================================
STEP 7 – SAFETY & VALIDATION
============================================================

- Always use safe parsing and default values when reading pricing-related data from LocalStorage.
- Ensure all new functions return sensible defaults (empty arrays or default settings) if no data exists.
- Validate numeric inputs in the admin forms (no NaN, percent between -100 and +100 where reasonable).
- Keep all new code strongly typed (TypeScript).
- Do NOT break any existing features.

============================================================
STEP 8 – FINAL CHECK
============================================================

1) Run:
   - npm install (if needed)
   - npm run build
2) Fix any TypeScript or compile errors.
3) Manually verify:
   - Admin can open “مركز التسعيرات” and fully configure:
     - Price levels
     - Product price matrix
     - Customer pricing profiles
     - Global pricing settings
   - Admin can change behavior (e.g. levels, percentages, precedence) and see changes reflected immediately in customer prices without touching code.
   - Customer portal uses the pricing engine to display correct prices according to the admin-defined configuration.
   - Any extra ideas/features you added are fully controlled via the admin UI, documented in the interface, and do not break existing functionality.

APPLY ALL THESE STEPS NOW, CAREFULLY AND IN ORDER.
