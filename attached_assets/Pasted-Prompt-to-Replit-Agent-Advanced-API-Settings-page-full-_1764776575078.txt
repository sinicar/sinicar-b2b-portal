Prompt to Replit Agent – Advanced API Settings page & full app integration

Act as a senior full-stack architect.
I want you to design and implement a professional API configuration & integration system for the Sini B2B portal.

Goal:

Have a single “API Settings” page in the admin where the owner can configure:

Global API mode (mock vs real backend)

Base URLs, auth, timeouts

Which modules/endpoints are exposed

Which fields/actions are shared externally

Connect all pages and buttons in the system to this central API layer instead of hardcoded calls.

Do not break existing mock/localStorage behavior. By default, the app should continue to work in mock mode until real API settings are provided.

1. Central API configuration model

Create or extend a strongly-typed config module, e.g.:

src/services/apiConfig.ts

It should include:

env: "development" | "production" | "test"

mode: "mock" | "live" | "hybrid"

baseUrl: string (main backend URL)

timeoutMs: number

retries: number

defaultHeaders: Record<string, string>

modules: per-module API settings, e.g.:

type ApiModuleConfig = {
  enabled: boolean;
  readEndpoint?: string;   // GET/SEARCH
  writeEndpoint?: string;  // POST/PUT/PATCH
  deleteEndpoint?: string;
  shareableFields?: string[]; // allowed fields for external sharing
  allowedMethods?: ('read' | 'write' | 'delete')[];
};

type ApiConfig = {
  env: 'development' | 'production' | 'test';
  mode: 'mock' | 'live' | 'hybrid';
  baseUrl: string;
  timeoutMs: number;
  retries: number;
  defaultHeaders: Record<string, string>;
  modules: {
    products: ApiModuleConfig;
    customers: ApiModuleConfig;
    quotes: ApiModuleConfig;
    imports: ApiModuleConfig;
    missing: ApiModuleConfig;
    accounts: ApiModuleConfig;
    activity: ApiModuleConfig;
    // etc…
  };
};


Read overrides from environment variables or Replit secrets, but keep sensible defaults so the app runs without them.

2. Unified HTTP client + routing by module

Create or refine a single HTTP client (httpClient.ts) that:

Reads global config from apiConfig.

Supports:

base URL

auth header/token (from config or future auth logic)

timeouts and retries

Exposes helpers, e.g.:

apiClient.callModule('products', 'read', options)
apiClient.callModule('quotes', 'write', payload)


Internally:

If apiConfig.mode === 'mock' OR the module is disabled → use existing mockApi/localStorage implementation.

If mode is 'live' and module is enabled → call the configured endpoint (readEndpoint, writeEndpoint, etc.).

If mode is 'hybrid' → allow some modules to use live endpoints and others to stay in mock.

This removes hardcoded URLs from components; everything goes through this central layer.

3. API Settings admin page (صفحة إعدادات API)

Build/upgrade the API Settings page under admin settings with these sections:

3.1 Global settings

Dropdown for mode:

Mock (local only)

Live (use real backend)

Hybrid

Inputs:

Base URL

Timeout (ms)

Retries

Button: "اختبار الاتصال" (Test Connection)

Calls a simple /health or /ping endpoint (configurable) and shows success/failure.

3.2 Module-level settings

For each main module (products, customers, quotes, imports, missing, accounts, activity…):

Toggle: تفعيل/تعطيل الربط API لهذا القسم (enabled)

Inputs for:

Read endpoint (GET/search)

Write endpoint (create/update)

Delete endpoint (optional)

Checkbox list for allowed methods:

قراءة (read)

كتابة (write)

حذف (delete)

3.3 Field-level sharing control (what can be shared)

For each module:

Show a list of key fields (with their internal names and Arabic labels), e.g. for products:

رقم الصنف

اسم المنتج

الماركة

الكمية

الأسعار

حالة التوفر

Allow checkboxes:

"مسموح بالمشاركة" لكل حقل.

These populate shareableFields array.

These flags will be used when generating payloads for external integrations or API sharing profiles so that only approved fields leave the system.

4. Integration profiles / sharable API keys (اختياري لكن مهم)

Add a sub-section: "ملفات تكامل / Profiles" where the owner can create integration profiles for partners.

Each profile should contain:

Profile name (e.g. "Insurance Company A", "Rental Partner B")

API key or token (auto-generated string)

Enabled modules for this partner (checkboxes per module)

Per-module allowed methods (read/write/delete)

Per-module allowed fields (subset of module shareableFields)

Store profiles in a config structure and prepare for future middleware where:

Incoming requests include an API key.

The system checks that key against the profile and enforces modules/methods/fields.

For now, even if actual HTTP server validation is not fully implemented, the config and UI should be ready and consistent.

5. Wiring all pages/buttons through the API layer

Review the app and:

Replace direct mockApi/localStorage calls with service functions that use apiClient.callModule.

At minimum, connect:

Products CRUD (list, create, update, delete)

Customer requests (open account, update data…)

Quotes (create, list, status updates)

Import from China requests

Missing parts logging and handling

CRM customer records

Activity log events

Provide clear mapping between UI actions and API modules:

For example, document in code:

Search bar in customer landing → module: 'products', method: 'read'.

"إرسال طلب تسعير" button → module: 'quotes', method: 'write'.

Admin updating status of an import → module: 'imports', method: 'write'.

Admin closing a missing part → module: 'missing', method: 'write'.

Ensure that if a module is disabled in API settings or in mock mode, the UI still works using local data without errors.

6. Preview & sharing of configuration

On the API Settings page, add:

A read-only summary or JSON preview of the current ApiConfig so the owner can see exactly what is configured.

A button: "نسخ إعدادات API" (Copy API config) that copies a sanitized JSON or YAML version to clipboard for documentation or sending to a backend developer.

When generating this view, include:

Global mode and base URL

Each module’s enabled/disabled status

Endpoints and allowed methods

Shareable fields

Do not include sensitive API keys or secrets in this copy unless they are explicitly marked as safe.

7. Safety, logging, and testing

Add robust error handling around API calls:

Centralized logging of failures (module, endpoint, status code, payload snippet).

User-friendly error messages in Arabic (e.g. "تعذر الاتصال بخادم API، الرجاء المحاولة لاحقًا").

Make sure:

App still works fully in mock mode.

Switching to live mode without configuring endpoints shows clear warnings in the API settings page.

Test flows:

Change mode (mock → live → hybrid) and confirm behavior.

Enable/disable modules and see that buttons behave correctly (no broken calls).

Update shareable fields and verify that generated payloads adhere to them (at least in the client-side building of request bodies).

Keep TypeScript types clean and ensure npm run build has no errors.

End of prompt.