Prompt to Replit Agent – Global indexing & filtering for all main pages

Act as a senior front-end + data engineer.
I want you to implement a unified indexing and filtering system for all main data tables in the Sini Admin / Sini Customer portal.

Goal:
Every main page that shows a table (products, customer requests, account requests, CRM customers, quotes, imports, missing, activity log, etc.) should support:

Fast, client-side indexed search (فهرسة)

Flexible filters (فلترة)

Consistent UX across the whole app

Do NOT break the existing UI design; instead, enhance it.

1. Central indexing & filtering engine

Create a reusable module, for example:

src/services/indexingFilterEngine.ts


This module should expose:

type IndexConfig = {
  entity: 'products' | 'customers' | 'requests' | 'imports' | 'missing' | 'activity' | string;
  getId: (row: any) => string;
  searchableFields: string[]; // e.g. ['partNumber', 'name', 'brand']
  keywordNormalizer?: (value: string) => string;
};

type FilterConfig<T> = {
  field: keyof T;
  type: 'text' | 'select' | 'status' | 'range' | 'date';
};

function createIndex<T>(rows: T[], config: IndexConfig): IndexedDataset<T>;

function queryIndex<T>(
  index: IndexedDataset<T>,
  options: {
    searchTerm?: string;
    filters?: Record<string, any>;
    sort?: { field: keyof T; direction: 'asc' | 'desc' };
  }
): T[];


Implementation guidelines:

Use a simple, in-memory index (no external DB):

For each row, build a normalized searchable string that concatenates the configured fields.

Store lowercase Arabic/English, removing extra spaces and punctuation.

Example normalizer:

convert to lowercase

remove diacritics if present

trim spaces

Make sure the engine is generic so any page can use it.

Provide a React hook wrapper, e.g.:

function useIndexedTable<T>(rows: T[], config: IndexConfig, filterConfig: FilterConfig<T>[]) {
  // returns { searchTerm, setSearchTerm, filters, setFilter, sortedFilteredRows, ... }
}

2. Search bar + filters UI for each main table

For each main page with a table (at least):

إدارة المنتجات (Products)

طلبات العملاء

طلبات الحسابات

قاعدة العملاء (CRM)

طلبات التسعير

طلبات الاستيراد

النواقص (Missing)

سجل النشاط

Do the following:

Add a unified search bar above the table (if not already present), connected to useIndexedTable:

Placeholder in Arabic, e.g.:

Products: "ابحث برقم الصنف، الاسم أو الماركة..."

Requests: "ابحث برقم العميل، الجوال أو حالة الطلب..."

Add a filter row / filter panel:

For text fields (like brand, customer name): text input filter.

For status fields (e.g. قيد التنفيذ، مكتمل، ملغي): dropdown/select filter.

For numeric fields (quantity, amount): min/max range filter.

For date fields (createdAt): from/to date picker.

Filters connect to the index engine via filters in queryIndex.

Use debounced search:

When the user types in the search bar, apply a small debounce (200–300 ms) before querying the index to keep UX smooth.

Keep pagination and sorting:

If existing tables already support pagination/sorting, apply queryIndex first, then paginate the result.

Sorting should be integrated with queryIndex’s sort option.

3. Arabic-friendly search (فهرسة تدعم العربية)

In the index engine:

Normalize strings in a way that supports Arabic:

Convert to lowercase.

Remove diacritics / Tatweel if present.

Trim spaces and unify multiple spaces.

Treat Arabic and English digits equivalently if needed.

Ensure searches are case-insensitive and not sensitive to extra spaces.

Example:

" جيلي COOLRAY " and "جيلي كولراي" should both match if the user searches "جيلي" or "كولراي".

4. Page-specific filter presets

For each major table, predefine useful filters:

Products:

Search: رقم الصنف، الاسم، الماركة.

Filters:

Brand (select)

Quantity range (e.g. < 5, 5–50, > 50)

Availability status (متوفر، غير متوفر، مخفي عن العملاء)

Customer Requests:

Search: رقم العميل، اسم المنشأة، رقم الجوال.

Filters:

حالة الطلب (جديد، تحت المراجعة، مكتمل، مرفوض)

نوع الطلب (فتح حساب، تعديل بيانات، إيقاف)

Missing (النواقص):

Search: رقم القطعة، اسم القطعة، العميل.

Filters:

availabilityStatus (not_found / out_of_stock)

handled / not handled

Imports:

Search: رقم الشحنة، اسم العميل، الدولة.

Filters:

حالة الشحنة (في المصنع، في البحر، في الميناء، مخلص جمركيًا)

Range: تاريخ الطلب أو تاريخ الوصول المتوقع.

Activity Log:

Search: اسم المستخدم، نوع الحدث.

Filters:

Event type (LOGIN, LOGOUT, PAGE_VIEW, ACTION, ERROR)

Date range

Online vs offline (reuse the online logic you already built).

Define these configs in a central place (e.g. tableConfigs.ts) so we can maintain them easily.

5. Performance & state management

Avoid rebuilding the index on every keystroke:

Build/refresh the index only when the base data changes (e.g. when mockApi data is updated).

Use useMemo or a similar mechanism.

Store current search and filter values in component state or a UI store (context), so when the user navigates back to a page, their last search/filter can be restored (optional but preferable).

Ensure there are no noticeable lags for a few thousand rows per table.

6. UX and consistency

All search bars should look visually consistent:

same height, font, padding, icons.

use the same search icon component.

All filter UIs should:

have clear labels in Arabic.

use consistent spacing and alignment.

have a "مسح الفلاتر" (Clear filters) button.

When no results match the search/filter:

Show a friendly message in Arabic, e.g.:

"لا توجد سجلات مطابقة لخيارات البحث الحالية."

7. Testing & cleanup

For each main page, test:

Simple keyword search (e.g. part number, customer name).

Combination of search + filters.

Reset filters and search.

Sorting + pagination with filters active.

Performance with several thousand rows.

Make sure npm run build passes and there are no runtime errors in the console.

Document in a small README_Indexing.md how:

to add a new indexed table,

to configure searchable fields,

to add filters for a new entity.

End of prompt.